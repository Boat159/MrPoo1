<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile MR + Hand Tracking</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 10;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(20,20,30,0.95) 0%, rgba(0,0,0,1) 100%);
        }
        #ar-ui {
            display: none; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 400px;
            background: rgba(20, 20, 30, 0.6); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 24px; padding: 15px; z-index: 20;
        }
        .hand-status {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5); padding: 5px 15px; border-radius: 20px;
            font-size: 12px; color: #4ade80; display: none;
        }
        .btn-select {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 10px; border-radius: 12px; font-weight: 600; text-align: center;
        }
        .btn-select.active { background: #3b82f6; border-color: #3b82f6; }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="overlay">
        <div class="text-center p-6 max-w-md">
            <h1 class="text-4xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Hand Tracking MR</h1>
            <p class="text-gray-400 mb-6">‡πÉ‡∏ä‡πâ‡∏°‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÇ‡∏•‡∏Å‡πÄ‡∏™‡∏°‡∏∑‡∏≠‡∏ô<br>‡∏à‡∏µ‡∏ö‡∏ô‡∏¥‡πâ‡∏ß (Pinch) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏</p>
            
            <div id="error-msg" class="hidden text-red-400 text-sm mb-4 bg-red-900/30 p-3 rounded border border-red-500/30"></div>

            <button id="start-ar" class="bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-full text-lg font-bold transition">
                ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (Start AR)
            </button>
            <p class="mt-4 text-xs text-gray-500">‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ Chrome Android & ‡πÄ‡∏õ‡∏¥‡∏î WebXR Hand Input</p>
        </div>
    </div>

    <!-- UI Overlay in AR -->
    <div id="ar-ui">
        <div id="hand-indicator" class="hand-status">üëã ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏°‡∏∑‡∏≠‡πÅ‡∏•‡πâ‡∏ß</div>
        
        <div class="flex justify-between items-center mb-2">
            <span class="text-xs text-gray-300">Gesture: Pinch to Spawn</span>
        </div>
        <div class="grid grid-cols-3 gap-2">
            <button class="btn-select active" onclick="setMode('cube', this)">üì¶ ‡∏Å‡∏•‡πà‡∏≠‡∏á</button>
            <button class="btn-select" onclick="setMode('sphere', this)">üîÆ ‡∏ö‡∏≠‡∏•</button>
            <button class="btn-select" onclick="setMode('virus', this)">ü¶† ‡πÑ‡∏ß‡∏£‡∏±‡∏™</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRHandModelFactory.js';

        let container, scene, camera, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        let hand1, hand2;
        let reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let currentSpawnType = 'cube';
        let lastPinchTime = 0; // Debounce for pinch gesture

        init();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Lighting
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 5, -5); // Light from slightly behind/above
            scene.add(dirLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Reticle (Targeting Ring)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x4ade80 }) // Green color
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Controllers & Hands Setup
            setupControllers();

            // AR Button Logic
            if (navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        document.getElementById('start-ar').addEventListener('click', onStartAR);
                    } else {
                        showError("‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö AR (‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Chrome ‡∏ö‡∏ô Android)");
                    }
                });
            } else {
                showError("WebXR ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Browser)");
            }

            window.addEventListener('resize', onWindowResize);
            window.setMode = (mode, btn) => {
                currentSpawnType = mode;
                document.querySelectorAll('.btn-select').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
        }

        function setupControllers() {
            // Setup standard controllers (for raycasting fallback)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', onSelect); // Tap screen fallback
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', onSelect);
            scene.add(controller2);

            // Setup Hand Models
            const handModelFactory = new XRHandModelFactory();

            // Hand 1
            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1, 'mesh')); // 'mesh' looks like a real hand, 'boxes' looks like joints
            scene.add(hand1);

            // Hand 2
            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2, 'mesh'));
            scene.add(hand2);

            // Listen for pinch events manually in the render loop for custom logic
        }

        async function onStartAR() {
            document.getElementById('overlay').style.display = 'none';
            
            const sessionInit = { 
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay', 'hand-tracking'], // Request hand tracking
                domOverlay: { root: document.getElementById('ar-ui') }
            };

            try {
                const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                renderer.xr.setReferenceSpaceType('local');
                renderer.xr.setSession(session);
                document.getElementById('ar-ui').style.display = 'block';
                
                session.addEventListener('end', () => {
                    document.getElementById('overlay').style.display = 'flex';
                    document.getElementById('ar-ui').style.display = 'none';
                    hitTestSourceRequested = false;
                    hitTestSource = null;
                });

                animate();
            } catch (e) {
                showError("Error starting AR: " + e.message);
                document.getElementById('overlay').style.display = 'flex';
            }
        }

        function onSelect() {
            // Fallback: If tap screen and reticle is visible
            if (reticle.visible) spawnObject(reticle.matrix);
        }

        function spawnObject(matrix) {
            let mesh;
            if (currentSpawnType === 'cube') {
                mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.2 })
                );
            } else if (currentSpawnType === 'sphere') {
                mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(0.1, 2),
                    new THREE.MeshPhysicalMaterial({ color: 0xff4400, transmission: 0.6, roughness: 0, thickness: 0.2 })
                );
            } else {
                // Virus / Spiky ball
                mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(0.1, 1),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: true })
                );
                // Simple animation hook could be added here
            }
            
            mesh.position.setFromMatrixPosition(matrix);
            mesh.position.y += 0.1; // Place slightly above surface
            
            // Add pop animation
            const targetScale = mesh.scale.clone();
            mesh.scale.set(0,0,0);
            
            let alpha = 0;
            const grow = () => {
                alpha += 0.1;
                mesh.scale.lerp(targetScale, alpha);
                if (alpha < 1) requestAnimationFrame(grow);
            };
            grow();

            scene.add(mesh);
        }

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.innerHTML = msg;
            el.classList.remove('hidden');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        // Check for Pinch Gesture
        function checkHandPinch(hand) {
            if (!hand.joints) return;

            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];

            if (indexTip && thumbTip) {
                const distance = indexTip.position.distanceTo(thumbTip.position);
                
                // If distance is less than 2cm (0.02 meters) -> Pinch detected
                if (distance < 0.02) {
                    const now = Date.now();
                    if (now - lastPinchTime > 500 && reticle.visible) { // Debounce 500ms
                        lastPinchTime = now;
                        spawnObject(reticle.matrix);
                        
                        // Haptic feedback (if supported)
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                             // Trying to vibrate gamepad if associated
                             // Simplified: just console log for now
                             console.log("Pinch Detected!");
                        }
                    }
                }
            }
        }

        function render(timestamp, frame) {
            if (frame) {
                // 1. Hit Test Logic
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }

                // 2. Hand Tracking Logic
                // Show indicator if hands are active
                const handsActive = (hand1 && hand1.joints && Object.keys(hand1.joints).length > 0) || 
                                    (hand2 && hand2.joints && Object.keys(hand2.joints).length > 0);
                
                const indicator = document.getElementById('hand-indicator');
                if (handsActive && indicator.style.display !== 'block') {
                    indicator.style.display = 'block';
                }

                // Check pinch for both hands
                if (hand1) checkHandPinch(hand1);
                if (hand2) checkHandPinch(hand2);
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


      
